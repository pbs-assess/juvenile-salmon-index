## Focus on recovering parameters for coho only

# devtools::install_github("https://github.com/pbs-assess/sdmTMB",
#                          ref = "mvrfrw")

library(tidyverse)
library(sdmTMB)
library(ggplot2)
library(sdmTMBextra)


ncores <- parallel::detectCores() 
future::plan(future::multisession, workers = 5L)


# make subdirectories for storage
dir.create("data/fits", recursive = TRUE, showWarnings = FALSE)

# downscale data and predictive grid
dat_in <- readRDS(here::here("data", "catch_survey_sbc.rds")) 


# downscale data and predictive grid
dat <- dat_in %>% 
  mutate(
    year_f = as.factor(year),
    yday = lubridate::yday(date),
    utm_x_1000 = utm_x / 1000,
    utm_y_1000 = utm_y / 1000,
    effort = log(volume_km3),
    scale_dist = scale(as.numeric(dist_to_coast_km))[ , 1],
    scale_depth = scale(as.numeric(target_depth))[ , 1],
    scale_yday = scale(as.numeric(yday))[ , 1],
    year_season_f = paste(year_f, season_f, sep = "_") %>% as.factor(),
    day_night = as.factor(day_night)) %>% 
  filter(species == "coho",
         # remove spring samples
         !season_f == "sp") %>%
  droplevels()


# same specs as normal
dat_coords <- dat %>% 
  select(utm_x_1000, utm_y_1000) %>% 
  as.matrix()
inla_mesh_raw <- INLA::inla.mesh.2d(
  loc = dat_coords,
  max.edge = c(2, 10) * 500,
  cutoff = 30,
  offset = c(10, 50)
)  
spde <- make_mesh(
  dat,
  c("utm_x_1000", "utm_y_1000"),
  mesh = inla_mesh_raw
) 

# fit model without season-specific spatial RFs and no spring data
fit <- sdmTMB(
  n_juv ~ 0 + season_f + survey_f + day_night + scale_dist +
    scale_depth,
  offset = dat$effort,
  data = dat,
  mesh = spde,
  family = sdmTMB::nbinom2(),
  spatial = "on",
  time = "year",
  spatiotemporal = "rw",
  anisotropy = TRUE,
  groups = "season_f",
  silent = FALSE
)

# simulate from year FE
set.seed(456)

f <- here::here("data", "fits", "nb_mcmc_draws_nb2_mvrfrw_coho.rds")
if (!file.exists(f)) {
  # hard coded with large values for cluster
  object <- fit
  samp <- sample_mle_mcmc(
    object, mcmc_iter = 220L, mcmc_warmup = 200L, mcmc_chains = 50L,
    stan_args = list(thin = 5L, cores = 50L)
  )
  # samp <- sample_mle_mcmc(object, mcmc_iter = 105, mcmc_warmup = 100)

  obj <- object$tmb_obj
  random <- unique(names(obj$env$par[obj$env$random]))
  pl <- as.list(object$sd_report, "Estimate")
  fixed <- !(names(pl) %in% random)
  map <- lapply(pl[fixed], function(x) factor(rep(NA, length(x))))
  obj <- TMB::MakeADFun(obj$env$data, pl, map = map, DLL = "sdmTMB")
  obj_mle <- object
  obj_mle$tmb_obj <- obj
  obj_mle$tmb_map <- map
  sim_out <- simulate(obj_mle, mcmc_samples = sdmTMBextra::extract_mcmc(samp), 
                      nsim = 200)

  saveRDS(sim_out, f)
} else {
  sim_out <- readRDS(f)
}

# fit model to sims
gc()
dir.create(here::here("data", "fits", "sim_fit"), showWarnings = FALSE)


# spread to list then fit 
sims_list <- apply(sim_out, 2, as.list)

f <- here::here("data", "fits", "sim_fit", "coho_nb2_mvrfrw.rds")
if (!file.exists(f)) {
  fit_sims_list <- furrr::future_map(
    sims_list,
    function(x) {
      dum_in <- dat %>% 
        mutate(
          sim_catch = as.numeric(x)
        )
      sdmTMB(
        sim_catch ~ 0 + season_f + survey_f + day_night + scale_dist +
          scale_depth,
        offset = dum_in$effort,
        data = dum_in,
        mesh = spde,
        family = sdmTMB::nbinom2(),
        spatial = "on",
        time = "year",
        spatiotemporal = "rw",
        anisotropy = TRUE,
        groups = "season_f",
        silent = TRUE
      )
    }
  )
  saveRDS(fit_sims_list, f)
} else {
  fit_sims_list <- readRDS(f)
}

### NOTE!!! Below will only be for coho. Might be easiest for you to generate
## the dataframe of simulated parameter estimates for this model and the
## other species and I can generate the box plot for the supplement.

# check parameter estimates
pars <- purrr::map(
  fit_sims_list, function (x) {
    fix <- tidy(x, effects = "fixed") 
    ran <- tidy(x, effects = "ran_pars") 
    
    # pull upsilon estimate separately (not currently generated by predict)
    est <- as.list(x$sd_report, "Estimate", report = TRUE)
    se <- as.list(x$sd_report, "Std. Error", report = TRUE)
    upsilon <- data.frame(
      term = "sigma_U",
      log_est = est$log_sigma_U,
      log_se = se$log_sigma_U
    ) %>% 
      mutate(
        estimate = exp(log_est),
        std.error = exp(log_se) 
      ) %>% 
      select(term, estimate, std.error)
    
    rbind(fix, ran, upsilon) %>% 
      # add unique identifier for second range term
      group_by(term) %>% 
      mutate(
        par_id = row_number(),
        term = ifelse(par_id > 1, paste(term, par_id, sep = "_"), term)
      ) %>% 
      ungroup() 
  }
) %>% 
  bind_rows()

# export (see equivalent snippet in par_recovery_sim.R)
dir.create(here::here("data", "preds"), showWarnings = FALSE)
saveRDS(pars, here::here("data", "preds", "sim_pars_mvrfrw.rds"))


# as above but for fitted model
fix <- tidy(fit, effects = "fixed")
ran <- tidy(fit, effects = "ran_pars")

# pull upsilon estimate separately (not currently generated by predict)
est <- as.list(fit$sd_report, "Estimate", report = TRUE)
se <- as.list(fit$sd_report, "Std. Error", report = TRUE)
upsilon <- data.frame(
  term = "sigma_U",
  log_est = est$log_sigma_U,
  log_se = se$log_sigma_U
) %>% 
  mutate(
    estimate = exp(log_est),
    std.error = exp(log_se) 
  ) %>% 
  select(term, estimate, std.error)

orig_pars <- rbind(fix, ran, upsilon) %>% 
  # add unique identifier for second range term
  group_by(term) %>% 
  mutate(
    par_id = row_number(),
    term = ifelse(par_id > 1, paste(term, par_id, sep = "_"), term)
  ) %>% 
  ungroup()

ggplot() +
  geom_boxplot(data = pars %>%
                 filter(!grepl("year", term)),
               aes(x = term, y = estimate)) +
  geom_point(data = orig_pars %>% 
               filter(!grepl("year", term)),
             aes(x = term, y = estimate), colour = "red") +
  facet_wrap(~term, scales = "free", ncol = 3) +
  labs(y = "Parameter Estimate", x =  "Species") +
  ggsidekick::theme_sleek() 


## generate indices

index_grid_hss <- readRDS(here::here("data", "index_hss_grid.rds")) %>% 
  filter(!season_f == "sp") 

sp_scalar <- 1 * (13 / 1000)

levels(dat$season_f)
index_grid_hss$season_f <- factor(index_grid_hss$season_f, levels = c("su", "wi"))
stopifnot(identical(levels(dat$season_f), levels(index_grid_hss$season_f)))

future::plan(future::multisession, workers = 4L)
# estimate season-specific index for each simulation draw 
sim_ind_list_summer <- furrr::future_map(
  fit_sims_list[1:100],
  function (x) {
    pp <- predict(x, 
                  newdata = index_grid_hss %>%
                    filter(season_f == "su") ,
                  se_fit = FALSE, re_form = NULL, return_tmb_object = TRUE)
    get_index(pp, area = sp_scalar, bias_correct = TRUE) %>%
      mutate(season_f = "su",
             species = "coho")
  }
)  
saveRDS(
  sim_ind_list_summer ,
  here::here("data", "fits", "sim_fit", "coho_summer_sim_index_final_mvrfrw.rds")
)
sim_ind_list_fall <- furrr::future_map(
  fit_sims_list[1:100],
  function (x) {
    pp <- predict(x, 
                  newdata = index_grid_hss %>%
                    filter(season_f == "wi"),
                  se_fit = FALSE, re_form = NULL, return_tmb_object = TRUE)
    get_index(pp, area = sp_scalar, bias_correct = TRUE) %>%
      mutate(season_f = "wi",
             species = "coho")
  }
)
saveRDS(
  sim_ind_list_fall ,
  here::here("data", "fits", "sim_fit", "coho_fall_sim_index_final_mvrfrw.rds")
)

