### Can fit parameters be recovered?
## Use simulated data generated by model in all_species_fit_season_mvrw to 
## determine whether parameters can be recovered.
## Sep 27, 2023


library(tidyverse)
library(sdmTMB)
library(ggplot2)
library(sdmTMBextra)

ncores <- parallel::detectCores() 
future::plan(future::multisession, workers = 5L)


# make subdirectories for storage
dir.create("data/fits", recursive = TRUE, showWarnings = FALSE)


# fitted model from all_species_fit.R
all_fit_tbl <- readRDS(
  here::here("data", "fits", "all_spatial_varying_nb2_mvrfrw_final.rds")
)


# simulate from Stan output fixing FEs at MLE
# output is list of species-specific matrices with ncol = nsim
# set.seed(456)
# sims_list <- furrr::future_map(
#   all_fit_tbl$fit, function (x) {
#     object <- x
#     samp <- sample_mle_mcmc(object, mcmc_iter = 120, mcmc_warmup = 100)
# 
#     obj <- object$tmb_obj
#     random <- unique(names(obj$env$par[obj$env$random]))
#     pl <- as.list(object$sd_report, "Estimate")
#     fixed <- !(names(pl) %in% random)
#     map <- lapply(pl[fixed], function(x) factor(rep(NA, length(x))))
#     obj <- TMB::MakeADFun(obj$env$data, pl, map = map, DLL = "sdmTMB")
#     obj_mle <- object
#     obj_mle$tmb_obj <- obj
#     obj_mle$tmb_map <- map
#     simulate(obj_mle, mcmc_samples = sdmTMBextra::extract_mcmc(samp), nsim = 10)
#   }
# )
# saveRDS(sims_list,
#         here::here("data", "fits", "nb_mcmc_draws_nb2_mvrfrw.rds"))

set.seed(456)
if (FALSE) {
sims_list <- furrr::future_map(
  all_fit_tbl$fit, function (x) {
    object <- x
    samp <- sample_mle_mcmc(object, mcmc_iter = 220L, mcmc_warmup = 200L, mcmc_chains = 50L,
                            stan_args = list(thin = 5L, cores = 50L))
    obj <- object$tmb_obj
    random <- unique(names(obj$env$par[obj$env$random]))
    pl <- as.list(object$sd_report, "Estimate")
    fixed <- !(names(pl) %in% random)
    map <- lapply(pl[fixed], function(x) factor(rep(NA, length(x))))
    obj <- TMB::MakeADFun(obj$env$data, pl, map = map, DLL = "sdmTMB")
    obj_mle <- object
    obj_mle$tmb_obj <- obj
    obj_mle$tmb_map <- map
    simulate(obj_mle, mcmc_samples = sdmTMBextra::extract_mcmc(samp), nsim = 200L)
  }
)
saveRDS(sims_list,
        here::here("data", "fits", "nb_mcmc_draws_nb2_mvrfrw.rds"))
}

sims_list <- readRDS(here::here("data", "fits", "nb_mcmc_draws_nb2_mvrfrw.rds"))


all_fit_tbl$sims <- sims_list

# check residuals
# dharma_list <- purrr::map2(all_fit_tbl$sims, all_fit_tbl$fit,
#                            function (x, y) {
#   pred_fixed <- y$family$linkinv(
#     predict(y,
#             newdata = y$data)$est_non_rf
#   )
#   r_nb <- DHARMa::createDHARMa(
#     simulatedResponse = x,
#     observedResponse = y$data$n_juv,
#     fittedPredictedResponse = pred_fixed
#   )
#   DHARMa::testResiduals(r_nb)
# }
# )


## for each simulated dataset, refit model, recover pars and store

# make a tibble for each species simulations
sim_tbl <- purrr::pmap(
  list(all_fit_tbl$species, all_fit_tbl$fit, all_fit_tbl$sims),
  function (sp, fits, x) {
    tibble(
      species = sp,
      iter = seq(1, ncol(x), by = 1),
      sim_dat = lapply(seq_len(ncol(x)), function(i) {
        # use fits instead of data in tibble because mismatched from extra_time
        fits$data %>% 
          mutate(sim_catch = x[ , i])
      })
    )
  }
) %>% 
  bind_rows() %>% 
  left_join(., 
            all_fit_tbl %>% select(species, fit), 
            by = c("species"))

sp_vec <- unique(sim_tbl$species)


## DISPERSION ------------------------------------------------------------------

all_fit_tbl$true_sd <- purrr::map(
  all_fit_tbl$data, ~ sd(.x$n_juv)
)

sim_tbl$sim_sd <- purrr::map(
  sim_tbl$sim_dat, ~ sd(.x$sim_catch)
)

sim_tbl %>% 
  select(species, sim_sd) %>% 
  left_join(., all_fit_tbl %>% select(species, true_sd), by = "species") %>% 
  unnest(cols = c(sim_sd, true_sd)) %>% 
  ggplot(.) +
  geom_boxplot(aes(x = as.factor(species), y = sim_sd)) +
  geom_point(aes(x = as.factor(species), y = true_sd), colour = "red")
  

## PROPORTION OF ZEROS ---------------------------------------------------------

# proportion zeros
purrr::map2(all_fit_tbl$data, all_fit_tbl$sims, function(x, y) {
  (sum(x$n_juv == 0) / length(x$n_juv)) / (sum(y == 0) / length(y))
})


## FIT SIMS  -------------------------------------------------------------------

gc()
dir.create(here::here("data", "fits", "sim_fit"), showWarnings = FALSE)
# fit model to species 

if (FALSE) {
for (i in seq_along(sp_vec)) {
  sim_tbl_sub <- sim_tbl %>% filter(species == sp_vec[i])
  fit <- furrr::future_map2(
    sim_tbl_sub$sim_dat, sim_tbl_sub$fit, 
    function (x, fit) {
      if (sp_vec[i] %in% c("chinook", "coho", "chum")) {
        sdmTMB(
          sim_catch ~ 0 + season_f + day_night + survey_f + scale_dist +
            scale_depth,
          offset = x$effort,
          data = x,
          mesh =  fit$spde,
          family = sdmTMB::nbinom2(),
          spatial = "off",
          spatial_varying = ~ 0 + season_f,
          time = "year",
          spatiotemporal = "rw",
          anisotropy = TRUE,
          groups = "season_f",
          control = sdmTMBcontrol(
            map = list(
              ln_tau_Z = factor(
                rep(1, times = length(unique(x$season_f)))
              )
            )
          ),
          silent = FALSE
        )
      } else {
        sdmTMB(
          sim_catch ~ 0 + season_f + day_night + survey_f + scale_dist +
            scale_depth + year_f,
          offset = x$effort,
          data = x,
          mesh =  fit$spde,
          family = sdmTMB::nbinom2(),
          spatial = "off",
          spatial_varying = ~ 0 + season_f,
          time = "year",
          spatiotemporal = "rw",
          anisotropy = TRUE,
          groups = "season_f",
          control = sdmTMBcontrol(
            map = list(
              ln_tau_Z = factor(
                rep(1, times = length(unique(x$season_f)))
              )
            )
          ),
          silent = FALSE
        )
      }
    }
  )
  saveRDS(
    fit,
    here::here("data", "fits", "sim_fit", 
               paste(sp_vec[i], "_nb2_mvrfrw.rds", sep = ""))
  )
  }

}
# import saved sim fits 
sim_fit_list <- purrr::map(
  sp_vec,
  ~ readRDS(
    here::here("data", "fits", "sim_fit", paste(.x, "_nb2_mvrfrw.rds", sep = ""))
  )
)

sim_tbl$sim_fit <- do.call(c, sim_fit_list)



## RECOVER PARAMETERS ----------------------------------------------------------

# extract fixed and ran effects pars from simulations
sim_tbl$pars <- purrr::map(
  sim_tbl$sim_fit, function (x) {
    fix <- tidy(x, effects = "fixed") 
    ran <- tidy(x, effects = "ran_pars") 
    
    # pull upsilon estimate separately (not currently generated by predict)
    est <- as.list(x$sd_report, "Estimate", report = TRUE)
    se <- as.list(x$sd_report, "Std. Error", report = TRUE)
    upsilon <- data.frame(
      term = "sigma_U",
      log_est = est$log_sigma_U,
      log_se = se$log_sigma_U
    ) %>% 
      mutate(
        estimate = exp(log_est),
        std.error = exp(log_se) 
      ) %>% 
      select(term, estimate, std.error)
    
    rbind(fix, ran, upsilon) %>% 
      # add unique identifier for second range term
      group_by(term) %>% 
      mutate(
        par_id = row_number(),
        term = ifelse(par_id > 1, paste(term, par_id, sep = "_"), term)
      ) %>% 
      ungroup() 
  }
)

sim_pars <- sim_tbl %>% 
  select(species, iter, pars) %>% 
  unnest(cols = c(pars)) %>% 
  mutate(
    iter = as.factor(iter),
    species = abbreviate(species, minlength = 3),
    term = fct_recode(
      as.factor(term), 
      "diel" = "day_nightNIGHT", "depth" = "scale_depth",
      "dist" = "scale_dist",
      "spring_int" = "season_fsp", 
      "summer_int" = "season_fsu", "fall_int" = "season_fwi", 
      # "spring_omega" = "sigma_Z", "summer_omega" = "sigma_Z_2",
      # "fall_omega" = "sigma_Z_3", "year_omega" = "sigma_Z_4", 
      "survey_design" = "survey_fipes"
    )
  ) 
dir.create(here::here("data", "preds"), showWarnings = FALSE)
saveRDS(sim_pars, here::here("data", "preds", "sim_pars_mvrfrw.rds"))


# as above but for fitted models
fit_effs <- purrr::map2(
  sim_tbl$fit, sim_tbl$species, function (x, sp) {
    fix <- tidy(x, effects = "fixed")
    ran <- tidy(x, effects = "ran_pars")
    
    # pull upsilon estimate separately (not currently generated by predict)
    est <- as.list(x$sd_report, "Estimate", report = TRUE)
    se <- as.list(x$sd_report, "Std. Error", report = TRUE)
    upsilon <- data.frame(
      term = "sigma_U",
      log_est = est$log_sigma_U,
      log_se = se$log_sigma_U
    ) %>% 
      mutate(
        estimate = exp(log_est),
        std.error = exp(log_se) 
      ) %>% 
      select(term, estimate, std.error)
    
    rbind(fix, ran, upsilon) %>% 
      mutate(species = abbreviate(sp, minlength = 3)) %>% 
      # add unique identifier for second range term
      group_by(term) %>% 
      mutate(
        par_id = row_number(),
        term = ifelse(par_id > 1, paste(term, par_id, sep = "_"), term)
      ) %>% 
      ungroup()
  }
) %>% 
  bind_rows() %>% 
  mutate(
    term = fct_recode(
      as.factor(term), "diel" = "day_nightNIGHT", "depth" = "scale_depth",
      "dist" = "scale_dist",
      "spring_int" = "season_fsp", 
      "summer_int" = "season_fsu", "fall_int" = "season_fwi", 
      # "spring_omega" = "sigma_Z", "summer_omega" = "sigma_Z_2",
      # "fall_omega" = "sigma_Z_3", "year_omega" = "sigma_Z_4", 
      "survey_design" = "survey_fipes"
    )
  )

sim_box <- ggplot() +
  geom_boxplot(data = sim_pars %>%
                 filter(!grepl("year", term)),
               aes(x = species, y = estimate)) +
  geom_point(data = fit_effs %>% 
               filter(!grepl("year", term)),
             aes(x = species, y = estimate), colour = "red") +
  facet_wrap(~term, scales = "free", ncol = 3) +
  labs(y = "Parameter Estimate", x =  "Species") +
  ggsidekick::theme_sleek() 

dir.create(here::here("figs"), showWarnings = FALSE)
dir.create(here::here("figs", "ms_figs_season_mvrw"), showWarnings = FALSE)
png(here::here("figs", "ms_figs_season_mvrw", "par_recovery_sim_box_mcmc.png"), 
    height = 8, width = 8, units = "in", res = 200)
sim_box
dev.off()



# RECOVER INDEX ----------------------------------------------------------------

# calculate proportion of grid cells without samples and scale colour ramp


# define years where survey occurred
# summer_years <- sim_tbl$fit[[1]]$data %>% 
#   filter(season_f == "su", 
#          # remove 2021 since only partial survey
#          !year_f == "2021") %>%
#   pull(year) %>% 
#   unique()
# fall_years <- sim_tbl$fit[[1]]$data %>%
#   filter(season_f == "wi",
#          # remove 2020 since most of survey was outside of grid
#          !year_f == "2020") %>%
#   pull(year) %>%
#   unique()

index_grid_hss <- readRDS(here::here("data", "index_hss_grid.rds")) %>% 
  mutate(day_night = as.factor(day_night),
         trim = ifelse(
           season_f == "wi" & utm_y_1000 < 5551, "yes", "no"
         )) %>%
  #subset to northern domain that's well sampled in recent years
  filter(trim == "no")


library(raster)

## create raster for each season's sampling grid
winter_grid <- index_grid_hss %>% 
  filter(year == "1998", season_f == "wi")  %>% 
  dplyr::select(X, Y) %>% 
  SpatialPoints(
    ., 
    proj4string = sp::CRS("+proj=utm +zone=9 +units=m")
  )
winter_raster <- rasterize(winter_grid, raster(extent(winter_grid), 
                                               res = c(5000, 5000)))

summer_grid <- index_grid_hss %>% 
  filter(year == "1998", season_f == "su")  %>% 
  dplyr::select(X, Y) %>% 
  SpatialPoints(
    ., 
    proj4string = sp::CRS("+proj=utm +zone=9 +units=m")
  )
summer_raster <- rasterize(summer_grid, raster(extent(summer_grid), 
                                               res = c(5000, 5000)))

# for each season-year combination identify proportion of cells sampled
# only need to do one species because set locations are identical
ys_key <- expand.grid(
  year = seq(min(all_fit_tbl$data[[1]]$year), max(all_fit_tbl$data[[1]]$year),
             by = 1),
  season_f = c("su", "wi")
) %>% 
  mutate(
    year_season_f = paste(year, season_f, sep = "_")
  )

ppn_coverage <- purrr::map(ys_key$year_season_f, function (x) {
  dd <- all_fit_tbl$data[[1]] %>% 
    filter(year_season_f == x)
  if (nrow(dd) == 0) {
    raster_values <- 0
  } else {
    points <- dd %>% 
      dplyr::select(utm_x, utm_y)
    sp_points <- SpatialPointsDataFrame(
      points, proj4string = sp::CRS("+proj=utm +zone=9 +units=m"), dd
    )  
    raster_with_border <- if(grepl("su", x)) summer_raster else winter_raster
    raster_values <- extract(raster_with_border, sp_points)
  }
  length(na.omit(raster_values)) / ncell(raster_with_border)
}) %>% 
  unlist()

ys_key2 <- ys_key %>% 
  mutate(
    ppn_coverage = ppn_coverage
  ) %>% 
  group_by(season_f) %>% 
  mutate(
    scale_coverage = ppn_coverage / max(ppn_coverage)
  ) %>% 
  ungroup()
  

sp_scalar <- 1 * (13 / 1000)


future::plan(future::multisession, workers = 2L)
# estimate season-specific index for each simulation draw 
for (i in seq_along(sp_vec)) {
  sim_tbl_sub <- sim_tbl %>% filter(species == sp_vec[i])
  sim_ind_list_summer <- furrr::future_map(
    sim_tbl_sub$sim_fit[1:100],
    function (x) {
      pp <- predict(x,
                    newdata = index_grid_hss %>%
                      filter(season_f == "su"),
                    se_fit = FALSE, re_form = NULL, return_tmb_object = TRUE)
      get_index(pp, area = sp_scalar, bias_correct = TRUE) %>%
        mutate(season_f = "su",
               species = sp_vec[i])
    }
  )
  saveRDS(
    sim_ind_list_summer ,
    here::here("data", "fits", "sim_fit",
               paste(sp_vec[i], "_summer_sim_index_final_mvrfrw.rds", sep = ""))
  )
  sim_ind_list_fall <- furrr::future_map(
    sim_tbl_sub$sim_fit[1:100],
    function (x) {
      pp <- predict(x, 
                    newdata = index_grid_hss %>%
                      filter(season_f == "wi"),
                    se_fit = FALSE, re_form = NULL, return_tmb_object = TRUE)
      get_index(pp, area = sp_scalar, bias_correct = TRUE) %>%
        mutate(season_f = "wi",
               species = sp_vec[i])
    }
  )
  saveRDS(
    sim_ind_list_fall ,
    here::here("data", "fits", "sim_fit",
               paste(sp_vec[i], "_fall_sim_index_final_mvrfrw.rds", sep = ""))
  )
}


# import saved indices from all_species_fit_season.R
true_index_list <- readRDS(
  here::here("data", "fits", "season_index_list_mvrfrw.rds")
)

true_index_summer <- furrr::future_map2(
  all_fit_tbl$fit, all_fit_tbl$species,
  function (x, y) {
    pp <- predict(x,
                  newdata = index_grid_hss %>%
                    filter(season_f == "su"),
                  se_fit = FALSE, re_form = NULL, return_tmb_object = TRUE)
    get_index(pp, area = sp_scalar, bias_correct = TRUE) %>%
      mutate(season_f = "su",
             species = y)
  }
)
true_index_fall <- furrr::future_map2(
  all_fit_tbl$fit, all_fit_tbl$species,
  function (x, y) {
    pp <- predict(x, 
                  newdata = index_grid_hss %>%
                    filter(season_f == "wi"),
                  se_fit = FALSE, re_form = NULL, return_tmb_object = TRUE)
    get_index(pp, area = sp_scalar, bias_correct = TRUE) %>%
      mutate(season_f = "wi",
             species = y)
  }
) 

true_ind_dat <- true_index_list %>%
  bind_rows() %>%
  # rbind(true_index_summer %>% bind_rows(), 
  #       true_index_fall %>% bind_rows()) %>% 
  mutate(
    season = fct_recode(season_f, "summer" = "su", "fall" = "wi"),
    log_lwr = log_est - (1.96 * se),
    log_upr = log_est + (1.96 * se),
    year_f = as.factor(year)
  )


sim_index_list_summer <- purrr::map(
  sp_vec,
  ~ readRDS(
    here::here("data", "fits", "sim_fit",
               paste(.x, "_summer_sim_index_final_mvrfrw.rds", sep = ""))
  )
)
sim_index_list_fall <- purrr::map(
  sp_vec,
  ~ readRDS(
    here::here("data", "fits", "sim_fit",
               paste(.x, "_fall_sim_index_final_mvrfrw.rds", sep = ""))
  ) 
)

n_iter <- length(sim_index_list_fall[[1]]) #how many sims per species?

sim_ind_dat <- tibble(
  # species = c(rep(sp_vec, each = n_iter), rep(sp_vec, each = n_iter)),
  iter = rep(seq(1, n_iter, by = 1), times = (length(sp_vec) * 2)),
  sim_index = c(do.call(c, sim_index_list_summer), 
                do.call(c, sim_index_list_fall))
) %>%
  unnest(cols = "sim_index") %>%
  left_join(
    ., 
    true_ind_dat %>% 
      select(species, year, year_f, season_f, true_log_est = log_est),
    by = c("species", "year", "season_f")) %>% 
  mutate(
    season = fct_recode(season_f, "summer" = "su", "fall" = "wi"),
    resid_est = true_log_est - log_est
  )


png(here::here("figs", "ms_figs_season_mvrw", "sim_index.png"), 
    height = 8, width = 8, units = "in", res = 200)
ggplot() +
  geom_boxplot(data = sim_ind_dat,
               aes(x = year_f, y = log_est)) +
  geom_point(data = true_ind_dat %>% filter(species %in% sp_vec),
             aes(x = year_f, y = log_est, colour = survey)) +
  facet_grid(species~season, scales = "free_y") +
  ggsidekick::theme_sleek() +
  theme(legend.position = "top") +
  scale_x_discrete(breaks = seq(2000, 2020, by = 5)) +
  labs(y = "Log Estimated Abundance") +
  theme(axis.title.x = element_blank())
dev.off()

png(here::here("figs", "ms_figs_season_mvrw", "resid_index.png"), 
    height = 8, width = 8, units = "in", res = 200)
ggplot() +
  geom_boxplot(data = sim_ind_dat,
               aes(x = year_f, y = resid_est)) +
  geom_hline(yintercept = 0, lty = 2, colour = "red") +
  facet_grid(species~season, scales = "free_y") +
  ggsidekick::theme_sleek() +
  theme(legend.position = "top") +
  scale_x_discrete(breaks = seq(2000, 2020, by = 5)) +
  labs(y = "Index Residuals") +
  theme(axis.title.x = element_blank())
dev.off()


